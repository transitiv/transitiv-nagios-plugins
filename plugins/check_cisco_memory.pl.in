#!@PERL@
# vim: et sts=4 sw=4 ts=4
# nagios: +epn
#
# @COPYRIGHT@
#
# Permission to use, copy, modify, and/or distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
#
# Please send comments, bugs and feature requests to @BUGREPORT@

use strict;
use warnings;

use Net::SNMP qw(:snmp);
use Nagios::Plugin;

sub get_oid_index {
    my $oid = shift;
    my $idx = rindex($oid, '.');

    return substr($oid, $idx + 1);
}

use constant {
    VERSION     => '@VERSION@',
    BLURB       => q{This plugin checks memory usage on Cisco devices supporting the
CISCO-MEMORY-POOL-MIB.},
    SHORTNAME   => 'Memory Usage',
    USAGE       => q{Usage: %s -H <host> -w <percent> -c <percent> [-2]
       [-p <port>] [-C <community>]},
    LICENSE     => q{@COPYRIGHT@

This plugin is free software, and comes with ABSOLUTELY NO WARRANTY.
It may be used, redistributed and/or modified under the terms of the
ISC Licence (see http://opensource.org/licenses/isc-license.txt).},
    TIMEOUT     => 10,
};

my $np = Nagios::Plugin->new(
    version     => VERSION,
    blurb       => BLURB,
    shortname   => SHORTNAME,
    usage       => USAGE,
    license     => LICENSE,
    timeout     => TIMEOUT,
);

use constant {
    # CISCO-MEMORY-POOL-MIB::ciscoMemoryPoolMIB
    OID_MEMORY_POOL         => '1.3.6.1.4.1.9.9.48.1.1.1',
    # CISCO-MEMORY-POOL-MIB::ciscoMemoryPoolName
    OID_MEMORY_POOL_NAME    => '1.3.6.1.4.1.9.9.48.1.1.1.2',
    # CISCO-MEMORY-POOL-MIB::ciscoMemoryPoolValid
    OID_MEMORY_POOL_VALID   => '1.3.6.1.4.1.9.9.48.1.1.1.4',
    # CISCO-MEMORY-POOL-MIB::ciscoMemoryPoolUsed
    OID_MEMORY_POOL_USED    => '1.3.6.1.4.1.9.9.48.1.1.1.5',
    # CISCO-MEMORY-POOL-MIB::ciscoMemoryPoolFree
    OID_MEMORY_POOL_FREE    => '1.3.6.1.4.1.9.9.48.1.1.1.6',
};

$np->add_arg(
    spec        => 'host|H=s',
    help        => q{IP address or hostname (use an IP address if possible to prevent a
   DNS query},
    label       => 'ADDRESS',
    required    => 1,
);

$np->add_arg(
    spec        => 'port|p=i',
    help        => 'Port number (default: %s)',
    default     => 161,
);

$np->add_arg(
    spec        => 'community|C=s',
    help        => 'SNMP community string (default: %s)',
    default     => 'public',
);

$np->add_arg(
    spec        => '2',
    help        => 'Use SNMP protocol version 2',
);

$np->add_arg(
    spec        => 'warning|w=i',
    help        => 'Exit with WARNING status if memory usage exceeds INTEGER%',
    required    => 1,
);

$np->add_arg(
    spec        => 'critical|c=i',
    help        => 'Exit with CRITICAL status if memory usage exceeds INTEGER%',
    required    => 1,
);

$np->getopts;

alarm $np->opts->timeout;

my ($session, $error) = Net::SNMP->session(
    -hostname   => $np->opts->host,
    -version    => $np->opts->{'2'} ? '2' : '1',
    -community  => $np->opts->community,
    -timeout    => $np->opts->timeout/4,
    -retries    => 1,
    -port       => $np->opts->port,
);

unless (defined($session)) {
    alarm 0;
    $np->nagios_die($error);
}

my $mem_table = $session->get_table(
    -baseoid    => OID_MEMORY_POOL,
);

unless (defined($mem_table)) {
    alarm 0;
    $error = $session->error;
    $session->close();
    $np->nagios_die($error);
}

$session->close();

my $pools = ();

foreach my $key (keys(%$mem_table)) {
    if (oid_base_match(OID_MEMORY_POOL_NAME, $key)) {
        my $idx = get_oid_index($key);
        $pools->{$idx}->{name} = $mem_table->{$key};
    } elsif (oid_base_match(OID_MEMORY_POOL_USED, $key)) {
        my $idx = get_oid_index($key);
        $pools->{$idx}->{used} = $mem_table->{$key};
    } elsif (oid_base_match(OID_MEMORY_POOL_FREE, $key)) {
        my $idx = get_oid_index($key);
        $pools->{$idx}->{free} = $mem_table->{$key};
    }
}

if (!keys(%$pools)) {
    $np->nagios_die("No memory pools found on this device");
}

my ($code, $message);

while (my ($key, $val) = each(%$pools)) {
    my $total = $val->{free} + $val->{used};
    my $used_pc = ($val->{used} / $total) * 100;
    my $warn = ($total / 100) * $np->opts->warning;
    my $crit = ($total / 100) * $np->opts->critical;

    $np->add_perfdata(
        label       => $val->{name},
        value       => $val->{used},
        uom         => 'B',
        min         => 0,
        max         => $total,
        warning     => $warn,
        critical    => $crit
    );

    $code = $np->check_threshold(
        check       => $used_pc,
        warning     => $np->opts->warning,
        critical    => $np->opts->critical
    );

    $np->add_message($code, sprintf(
        "%s: %.1f%%",
        $val->{name},
        $used_pc
    ));
}

($code, $message) = $np->check_messages(join => ', ');
$np->nagios_exit($code, $message);
